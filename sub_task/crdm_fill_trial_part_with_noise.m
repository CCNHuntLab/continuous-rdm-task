function [ block ] = crdm_fill_trial_part_with_noise( f, block, flag )
%CRDM_FILL_TRIAL_PART_WITH_NOISE This function uses the pure noise stream
%for the current block to fill the remainder of a trial after a button
%press with random (incoherent) dot motion. 
% It updates three block variables for the remaining frames of this trial: 
%   stimulus.xy: the xy coordinates of dots generated by the pure noise stream
%       (these will be taken from the noise stream: xy_noise)
%   coherences.meanCohPerFrame: the frame-wise mean coherence that generated the
%       frame-wise actual coherences (these will be set to zero = noise)
%   coherences.trialCohPerFrame: the frame-wise actual coherences that
%       generated the xy coordinates of dots (these will be taken from the
%       noise stream: noiseCohPerFrame)
%
% IN:   f       - the current frame
%       block   - the struct that contains block-specific info and stimulus
%       flag    - if zero, nothing is done - this is used to call the function 
%               for the first time for speed reasons
%
% OUT:  block   - the updated struct for this block

if flag == 0 
    % do nothing - this is used to dummy call the function before the first
    % block of the current session actually starts
else
    % get trial number (should be equal to trial??)
    trialNum = block.epochs.trialPositionVector(f);
    
    % get idx of first frame of this coherent motion trial
    idxTrialStart = find(block.epochs.trialPositionVector == trialNum, 1, ...
        'first');
    
    % get start frame of next incoherent motion period
    idxNextItiStart = idxTrialStart + block.trial.length + 1;
    
    % now, calculate amount of frames from current one (in which participant 
    % has responded) to the beginning of the next ITI (i.e., incoherent motion)
    noiseFrames = length(f+1 : idxNextItiStart) +1;
    
    % update stimulus (xy dot positions) using the noise stimulus, 
    % set mean coherence to 0 for remaining coherence frames, 
    % and also update trial coherences accordingly
    block.stimulus.xy(:, :, f+1 : idxNextItiStart) = ...
        block.stimulus.xy_noise(:, :, f+1 : idxNextItiStart); 
    block.coherences.meanCohPerFrame(f+1 : idxNextItiStart +1) = ...
        zeros(noiseFrames, 1);
    block.coherences.trialCohPerFrame(f+1 : idxNextItiStart +1) ...
        = block.coherences.noiseCohPerFrame(f+1 : idxNextItiStart +1);
end

end
